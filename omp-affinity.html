<html>
<head>

<link href="ihpsc.css" rel="stylesheet" type="text/css">

  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/css/bootstrap.min.css" integrity="sha384-Gn5384xqQ1aoWXA+058RXPxPg6fy4IWvTNh0E263XmFcJlSAwiGgFAW/dAiS6JXm" crossorigin="anonymous">

  <script src="https://code.jquery.com/jquery-3.2.1.slim.min.js" integrity="sha384-KJ3o2DKtIkvYIK3UENzmM7KCkRr/rE9/Qpg6aAZGJwFDMVNA/GpGFF93hXpG5KkN" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.12.9/umd/popper.min.js" integrity="sha384-ApNbgh9B+Y1QKtv3Rn7W3mgPxhU9K/ScQsAP7hUibX39j7fakFPskvXusvfa0b4Q" crossorigin="anonymous"></script>
  <script src="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/js/bootstrap.min.js" integrity="sha384-JZR6Spejh4U02d8jOt6vLEHfe/JQGiRRSQQxSfFWpi1MquVdAyjUar5+76PVCmYl" crossorigin="anonymous"></script>


  <!-- mathjax stuff -->
  <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {inlineMath: [['$','$']]}
  });
  MathJax.Hub.Config({
    TeX: { equationNumbers: { autoNumber: "AMS" } }
  });
  </script>

  <link rel="stylesheet"
      href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.13.1/styles/default.min.css">
  <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.13.1/highlight.min.js"></script>
  <script>hljs.initHighlightingOnLoad();</script>
</head>


<script type="application/javascript">
  // First we declare some metadata, primarily to describe
  // the container environment.
  var ccrsApiNamespace = "org.xsede.jobrunner.model.ModelApi";
  var mpiExampleMetaJson = {
    // CHANGE: for now, leave the appended string as .SysJobMetaData;
    //         other options will be supported in the future
    "$type": ccrsApiNamespace + ".SysJobMetaData",
    // CHANGE: shell to use implicitly when running commands in the container
    "shell": ["bash"],
    // CHANGE: should currently be one of: .NixOS, .Singularity
    "containerType": {
      "$type":  ccrsApiNamespace + ".NixOS"
    },
    // CHANGE: Specify for NixOS for all jobs, or for Singularity when resuming existing jobs
    "containerId": ["vicOpenMPI"],
    // CHANGE: Specify the singularity image name
    "image": [],
    // Directories on the host to mount in the container, if any:
    "binds": [],
    // Only for singularity:
    "overlay": [],
    // CHANGE: should be filled in dynamically to contain the (student) user,
    //         but this is a demo, so we use a static user name:
    "user": "test0",
    "address": [],
    "hostname": [],
    "url": window.location.href
  };
  var mpiExampleMeta = CCRS.sysJobMetaData(mpiExampleMetaJson);
</script>


<div class="container">
  <div class="row">
    <div class="col-12">
      <div class="pagehead">
        <h1>OpenMP topic: Affinity</h1>
        <h5>Experimental html version of
Parallel Programming in MPI, OpenMP, and PETSc
by Victor Eijkhout.
download the textbook at https:/theartofhpc.com/pcse</h5>
      </div>
    </div>
  </div>
  <div>



\[
\newcommand\inv{^{-1}}\newcommand\invt{^{-t}}
\newcommand\bbP{\mathbb{P}}
\newcommand\bbR{\mathbb{R}}
\newcommand\defined{
\mathrel{\lower 5pt \hbox{${\equiv\atop\mathrm{\scriptstyle D}}$}}}
\]


25.1 : <a href="omp-affinity.html#OpenMPthreadaffinitycontrol">OpenMP thread affinity control</a><br>

25.1.1 : <a href="omp-affinity.html#Threadbinding">Thread binding</a><br>

25.1.2 : <a href="omp-affinity.html#Effectsofthreadbinding">Effects of thread binding</a><br>

25.1.3 : <a href="omp-affinity.html#Placedefinition">Place definition</a><br>

25.1.4 : <a href="omp-affinity.html#Bindingpossibilities">Binding possibilities</a><br>

25.2 : <a href="omp-affinity.html#First-touch">First-touch</a><br>

25.2.1 : <a href="omp-affinity.html#C++">C++</a><br>

25.2.2 : <a href="omp-affinity.html#Remarks">Remarks</a><br>

25.3 : <a href="omp-affinity.html#AffinitycontroloutsideOpenMP">Affinity control outside OpenMP</a><br>

25.4 : <a href="omp-affinity.html#Tests">Tests</a><br>

25.4.1 : <a href="omp-affinity.html#Lonestar6">Lonestar 6</a><br>

25.4.2 : <a href="omp-affinity.html#Frontera">Frontera</a><br>

25.4.3 : <a href="omp-affinity.html#Stampede2skylake">Stampede2 skylake</a><br>

25.4.4 : <a href="omp-affinity.html#Stampede2KnightsLanding">Stampede2 Knights Landing</a><br>

25.4.5 : <a href="omp-affinity.html#Longhorn">Longhorn</a><br>

<a href="index.html">Back to Table of Contents</a>
<h1>25 OpenMP topic: Affinity</h1>
<p name="switchToTextMode:starting TeXFileScanner">
<!-- TranslatingLineGenerator file -->
</p name="switchToTextMode:blank literal line">




<h2><a id="OpenMPthreadaffinitycontrol">25.1</a> OpenMP thread affinity control</h2>
<p name="switchToTextMode:write non-code line">
crumb trail:  > <a href="omp-affinity.html">omp-affinity</a> > <a href="omp-affinity.html#OpenMPthreadaffinitycontrol">OpenMP thread affinity control</a>
</p name="switchToTextMode:blank literal line">


<p name="switchToTextMode:write non-code line">
The matter of thread affinity becomes important on 
<i>multi-socket nodes</i>
%
;
see the example in section&nbsp;
<a href="omp-affinity.html#First-touch">25.2</a>
&nbsp;.
</p name="switchToTextMode:blank literal line">


<p name="switchToTextMode:write non-code line">
Thread placement can be controlled with two environment variables:
<!-- environment: itemize start embedded generator -->
<ul>
<!-- TranslatingLineGenerator itemize -->
<li>
the environment variable 
<!-- index:OMP_PROC_BIND --><tt>OMP_PROC_BIND</tt>
  describes how threads are bound to 
<i>OpenMP places</i>
; while
<li>
the variable 
<!-- index:OMP_PLACES --><tt>OMP_PLACES</tt>
 describes these places
  in terms of the available hardware.
<li>
When you're experimenting with these variables it is a good idea
  to set 
<!-- index:OMP_DISPLAY_ENV --><tt>OMP_DISPLAY_ENV</tt>
 to true, so that OpenMP will
  print out at runtime how it has interpreted your specification.
  The examples in the following sections will display this output.
<!-- translatinglinegenerator end: itemize -->
</ul>
<!-- environment: itemize end embedded generator -->
</p name="switchToTextMode:blank literal line">


<h3><a id="Threadbinding">25.1.1</a> Thread binding</h3>
<p name="switchToTextMode:write non-code line">
crumb trail:  > <a href="omp-affinity.html">omp-affinity</a> > <a href="omp-affinity.html#OpenMPthreadaffinitycontrol">OpenMP thread affinity control</a> > <a href="omp-affinity.html#Threadbinding">Thread binding</a>
</p name="switchToTextMode:blank literal line">


<p name="switchToTextMode:write non-code line">
The variable 
<!-- index:OMP_PLACES --><tt>OMP_PLACES</tt>
 defines a series of places to
which the threads are assigned,
and 
<!-- index:OMP_PROC_BIND --><tt>OMP_PROC_BIND</tt>
 describes how threads are tied to those places.
</p name="switchToTextMode:blank literal line">


<p name="switchToTextMode:write non-code line">
Typical values for 
<!-- index:OMP_PLACES --><tt>OMP_PLACES</tt>
 are
<!-- environment: itemize start embedded generator -->
<ul>
<!-- TranslatingLineGenerator itemize -->
<li>
<!-- index:socket --><tt>socket</tt>
: threads are bound to a 
<!-- index:socket --><i>socket</i>
&nbsp;, but can be
  moved between cores in the socket;
<li>
<!-- index:core --><tt>core</tt>
: threads are bound to a 
<!-- index:core --><i>core</i>
&nbsp;, but
  can be moved between hyperthreads in the core;
<li>
<!-- index:thread --><tt>thread</tt>
: threads are bound to a specific 
<!-- index:hyper-thread --><i>hyper-thread</i>
&nbsp;.
<!-- translatinglinegenerator end: itemize -->
</ul>
<!-- environment: itemize end embedded generator -->
</p name="switchToTextMode:blank literal line">


<p name="switchToTextMode:write non-code line">
Values for 
<!-- index:OMP_PROC_BIND --><tt>OMP_PROC_BIND</tt>
 are implementation-defined,
but typically:
<!-- environment: itemize start embedded generator -->
<ul>
<!-- TranslatingLineGenerator itemize -->
<li>
<!-- index:master --><tt>master</tt>
: threads are bound to the same place as the master thread;
<li>
<!-- index:close --><tt>close</tt>
: subsequent thread numbers are placed close together
  in the defined places;
<li>
<!-- index:spread --><tt>spread</tt>
: subsequent thread numbers are maxially spread over places;
<li>
<!-- index:true --><tt>true</tt>
: threads are bound to their initial placement;
<li>
<!-- index:false --><tt>false</tt>
: threads are not bound to their initial placement;
<!-- translatinglinegenerator end: itemize -->
</ul>
<!-- environment: itemize end embedded generator -->
where the values 
<tt>master,close,spread</tt>
 are ordained by the standard,
and the others depend on the implementation.
</p name="switchToTextMode:blank literal line">


<p name="switchToTextMode:write non-code line">
There is no runtime function for setting the binding, but the 
<span title="acronym" ><i>ICV</i></span>
<!-- index:bind-var --><tt>bind-var</tt>
can be retrieved with 
<!-- index:omp_get_proc_bind --><tt>omp_get_proc_bind</tt>
&nbsp;.
The binding can also be set with the 
\indexompclause{proc_bind} clause
on the 
<tt>parallel</tt>
 directive,
with values 
<tt>master,close,spread</tt>
&nbsp;.
</p name="switchToTextMode:blank literal line">


<p name="switchToTextMode:write non-code line">
Example: if you have two sockets and you define
<!-- environment: verbatim start embedded generator -->
<pre>
OMP_PLACES=sockets
</pre>
<!-- environment: verbatim end embedded generator -->
then
<!-- environment: itemize start embedded generator -->
<ul>
<!-- TranslatingLineGenerator itemize -->
<li>
thread 0 goes to socket 0,
<li>
thread 1 goes to socket 1,
<li>
thread 2 goes to socket 0 again,
<li>
and so on.
<!-- translatinglinegenerator end: itemize -->
</ul>
<!-- environment: itemize end embedded generator -->
On the other hand, if the two sockets have a total of sixteen cores
and you define
<!-- environment: verbatim start embedded generator -->
<pre>
OMP_PLACES=cores
OMP_PROC_BIND=close
</pre>
<!-- environment: verbatim end embedded generator -->
then
<!-- environment: itemize start embedded generator -->
<ul>
<!-- TranslatingLineGenerator itemize -->
<li>
thread 0 goes to core 0, which is on socket&nbsp;0,
<li>
thread 1 goes to core 1, which is on socket&nbsp;0,
<li>
thread 2 goes to core 2, which is on socket&nbsp;0,
<li>
and so on, until thread 7 goes to core 7 on socket&nbsp;0, and
<li>
thread 8 goes to core 8, which is on socket&nbsp;1,
<li>
et cetera.
<!-- translatinglinegenerator end: itemize -->
</ul>
<!-- environment: itemize end embedded generator -->
The value 
<tt>OMP_PROC_BIND=close</tt>
 means that the assignment goes
successively through the available places.
The variable 
<tt>OMP_PROC_BIND</tt>
 can also be set to 
<tt>spread</tt>
&nbsp;, which
spreads the threads over the places.
With
<!-- environment: verbatim start embedded generator -->
<pre>
OMP_PLACES=cores
OMP_PROC_BIND=spread
</pre>
<!-- environment: verbatim end embedded generator -->
you find that
<!-- environment: itemize start embedded generator -->
<ul>
<!-- TranslatingLineGenerator itemize -->
<li>
thread 0 goes to core 0, which is on socket&nbsp;0,
<li>
thread 1 goes to core 8, which is on socket&nbsp;1,
<li>
thread 2 goes to core 1, which is on socket&nbsp;0,
<li>
thread 3 goes to core 9, which is on socket&nbsp;1,
<li>
and so on, until thread 14 goes to core 7 on socket&nbsp;0, and
<li>
thread 15 goes to core 15, which is on socket&nbsp;1.
<!-- translatinglinegenerator end: itemize -->
</ul>
<!-- environment: itemize end embedded generator -->
</p name="switchToTextMode:blank literal line">


<p name="switchToTextMode:write non-code line">
So you see that 
<tt>OMP_PLACES=cores</tt>
 and 
<tt>OMP_PROC_BIND=spread</tt>
 very
similar to 
<tt>OMP_PLACES=sockets</tt>
&nbsp;. The difference is that the latter
choice does not bind a thread to a specific core, so the operating
system can move threads about, and it can put more than one thread on
the same core, even if there is another core still unused.
</p name="switchToTextMode:blank literal line">


<p name="switchToTextMode:write non-code line">
The value 
<tt>OMP_PROC_BIND=master</tt>
 puts the threads in the same place
as the master of the team. This is convenient if you create teams
recursively. In that case you would use the 
\indexclause{proc\_bind}
clause rather than the environment variable, set to 
<tt>spread</tt>
 for the
initial team, and to 
<tt>master</tt>
 for the recursively created team.
</p name="switchToTextMode:blank literal line">


<h3><a id="Effectsofthreadbinding">25.1.2</a> Effects of thread binding</h3>
<p name="switchToTextMode:write non-code line">
crumb trail:  > <a href="omp-affinity.html">omp-affinity</a> > <a href="omp-affinity.html#OpenMPthreadaffinitycontrol">OpenMP thread affinity control</a> > <a href="omp-affinity.html#Effectsofthreadbinding">Effects of thread binding</a>
</p name="switchToTextMode:blank literal line">


<p name="switchToTextMode:write non-code line">
Let's consider two example program. First we consider the program for
computing&nbsp;$\pi$, which is purely compute-bound.
</p name="switchToTextMode:blank literal line">


<p name="switchToTextMode:starting EnvironmentLineGenerator">
</p name="switchToTextMode:starting TabularLineGenerator">

<p name="switchToTextMode:starting TranslatingLineGenerator">
<!-- environment: tabular start embedded generator -->
<table>
<tr>
<td>
<!-- TranslatingLineGenerator tabular -->
  \toprule
  \#threads</td><td>
<tt>close/cores</tt>
</td><td>
<tt>spread/sockets</tt>
</td><td>
<tt>spread/cores</tt>
</td></tr>
<tr><td>
  \midrule
   1</td><td> 0.359</td><td> 0.354</td><td> 0.353</td></tr>
<tr><td>
   2</td><td> 0.177</td><td> 0.177</td><td> 0.177</td></tr>
<tr><td>
   4</td><td> 0.088</td><td> 0.088</td><td> 0.088</td></tr>
<tr><td>
   6</td><td> 0.059</td><td> 0.059</td><td> 0.059</td></tr>
<tr><td>
   8</td><td> 0.044</td><td> 0.044</td><td> 0.044</td></tr>
<tr><td>
  12</td><td> 0.029</td><td> 0.045</td><td> 0.029</td></tr>
<tr><td>
  16</td><td> 0.022</td><td> 0.050</td><td> 0.022</td></tr>
<tr><td>
  \bottomrule
<!-- translatinglinegenerator end: tabular -->
</td>
</tr>
</table>
<!-- environment: tabular end embedded generator -->
</p name="switchToTextMode:blank literal line">


<p name="switchToTextMode:write non-code line">
We see pretty much perfect speedup for the 
<tt>OMP_PLACES=cores</tt>
strategy; with 
<tt>OMP_PLACES=sockets</tt>
 we probably get occasional
collisions where two threads wind up on the same core.
</p name="switchToTextMode:blank literal line">


<p name="switchToTextMode:write non-code line">
Next we take a program for computing the time evolution of the
<!-- index:heat equation --><i>heat equation</i>
:
<!-- environment: equation start embedded generator -->
\begin{equation}
t=0,1,2,&hellip;\colon \forall_i\colon
x^{(t+1)}_i = 2x^{(t)}_i-x^{(t)}_{i-1}-x^{(t)}_{i+1}
\end{equation}
<!-- environment: equation end embedded generator -->
This is a bandwidth-bound operation because the amount of computation
per data item is low.
</p name="switchToTextMode:blank literal line">


<p name="switchToTextMode:starting EnvironmentLineGenerator">
</p name="switchToTextMode:starting TabularLineGenerator">

<p name="switchToTextMode:starting TranslatingLineGenerator">
<!-- environment: tabular start embedded generator -->
<table>
<tr>
<td>
<!-- TranslatingLineGenerator tabular -->
  \toprule
  \#threads</td><td>
<tt>close/cores</tt>
</td><td>
<tt>spread/sockets</tt>
</td><td>
<tt>spread/cores</tt>
</td></tr>
<tr><td>
  \midrule
   1</td><td> 2.88</td><td> 2.89</td><td> 2.88</td></tr>
<tr><td>
   2</td><td> 1.71</td><td> 1.41</td><td> 1.42</td></tr>
<tr><td>
   4</td><td> 1.11</td><td> 0.74</td><td> 0.74</td></tr>
<tr><td>
   6</td><td> 1.09</td><td> 0.57</td><td> 0.57</td></tr>
<tr><td>
   8</td><td> 1.12</td><td> 0.57</td><td> 0.53</td></tr>
<tr><td>
  12</td><td> 0.72</td><td> 0.53</td><td> 0.52</td></tr>
<tr><td>
  16</td><td> 0.52</td><td> 0.61</td><td> 0.53</td></tr>
<tr><td>
  \bottomrule
<!-- translatinglinegenerator end: tabular -->
</td>
</tr>
</table>
<!-- environment: tabular end embedded generator -->
</p name="switchToTextMode:blank literal line">


<p name="switchToTextMode:write non-code line">
Again we see that 
<tt>OMP_PLACES=sockets</tt>
 gives worse performance for
high core counts,
probably because of threads winding up on the same core.
The thing to observe in this example is that with 6&nbsp;or&nbsp;8 cores the
<tt>OMP_PROC_BIND=spread</tt>
 strategy gives twice the performance of
<tt>OMP_PROC_BIND=close</tt>
&nbsp;.
</p name="switchToTextMode:blank literal line">


<p name="switchToTextMode:write non-code line">
The reason for this is that a single socket
does not have enough bandwidth for all eight cores on the
socket. Therefore, dividing the eight threads over two sockets gives
each thread a higher available bandwidth than putting all threads on
one socket.
</p name="switchToTextMode:blank literal line">


<h3><a id="Placedefinition">25.1.3</a> Place definition</h3>
<p name="switchToTextMode:write non-code line">
crumb trail:  > <a href="omp-affinity.html">omp-affinity</a> > <a href="omp-affinity.html#OpenMPthreadaffinitycontrol">OpenMP thread affinity control</a> > <a href="omp-affinity.html#Placedefinition">Place definition</a>
</p name="switchToTextMode:blank literal line">


<p name="switchToTextMode:write non-code line">
There are three predefined values for the 
<!-- index:OMP_PLACES --><tt>OMP_PLACES</tt>
variable: 
<tt>sockets, cores, threads</tt>
&nbsp;. You have already seen the first
two; the 
<tt>threads</tt>
 value becomes relevant on processors that have
hardware threads. In that case, 
<tt>OMP_PLACES=cores</tt>
 does not tie a
thread to a specific hardware thread, leading again to possible
collisions as in the above example. Setting 
<tt>OMP_PLACES=threads</tt>
ties each OpenMP thread to a specific hardware thread.
</p name="switchToTextMode:blank literal line">


<p name="switchToTextMode:write non-code line">
There is also a very general syntax for defining places that uses a
<!-- environment: verbatim start embedded generator -->
<pre>
  location:number:stride
</pre>
<!-- environment: verbatim end embedded generator -->
syntax. Examples:
<!-- environment: itemize start embedded generator -->
<ul>
<!-- TranslatingLineGenerator itemize -->
<li>
<!-- environment: verbatim start embedded generator -->
<pre>
OMP_PLACES="{0:8:1},{8:8:1}"
</pre>
<!-- environment: verbatim end embedded generator -->
  is equivalent to
<tt>sockets</tt>
 on a two-socket design with eight cores per socket: it
  defines two places, each having eight consecutive cores. The threads
  are then places alternating between the two places, but not further
  specified inside the place.
<li>
The setting 
<tt>cores</tt>
 is equivalent to
<!-- environment: verbatim start embedded generator -->
<pre>
OMP_PLACES="{0},{1},{2},...,{15}"
</pre>
<!-- environment: verbatim end embedded generator -->
<li>
On a four-socket design, the specification
<!-- environment: verbatim start embedded generator -->
<pre>
OMP_PLACES="{0:4:8}:4:1"
</pre>
<!-- environment: verbatim end embedded generator -->
  states that the place 
<tt>0,8,16,24</tt>
 needs to be repeated four times,
  with a stride of one. In other words,  thread&nbsp;0 winds up on
  core&nbsp;0 of some socket, the thread&nbsp;1 winds up on core&nbsp;1 of some
  socket, et cetera.
<!-- translatinglinegenerator end: itemize -->
</ul>
<!-- environment: itemize end embedded generator -->
</p name="switchToTextMode:blank literal line">


<h3><a id="Bindingpossibilities">25.1.4</a> Binding possibilities</h3>
<p name="switchToTextMode:write non-code line">
crumb trail:  > <a href="omp-affinity.html">omp-affinity</a> > <a href="omp-affinity.html#OpenMPthreadaffinitycontrol">OpenMP thread affinity control</a> > <a href="omp-affinity.html#Bindingpossibilities">Binding possibilities</a>
</p name="switchToTextMode:blank literal line">


<p name="switchToTextMode:write non-code line">
Values for 
<!-- index:OMP_PROC_BIND --><tt>OMP_PROC_BIND</tt>
 are: 
<tt>false, true, master, close, spread</tt>
&nbsp;.
<!-- environment: itemize start embedded generator -->
<ul>
<!-- TranslatingLineGenerator itemize -->
<li>
false: set no binding 
<li>
true: lock threads to a core 
<li>
  master: collocate threads with the master thread 
<li>
close: place
  threads close to the master in the places list 
<li>
spread: spread
  out threads as much as possible
<!-- translatinglinegenerator end: itemize -->
</ul>
<!-- environment: itemize end embedded generator -->
</p name="switchToTextMode:blank literal line">


<p name="switchToTextMode:write non-code line">
This effect can be made local by
giving the 
\indexclause{proc\_bind} clause in the
<tt>parallel</tt>
 directive.
</p name="switchToTextMode:blank literal line">


<p name="switchToTextMode:write non-code line">
A safe default setting is
<!-- environment: verbatim start embedded generator -->
<pre>
export OMP_PROC_BIND=true
</pre>
<!-- environment: verbatim end embedded generator -->
which prevents the operating system from
<i>migrating a thread</i>
&nbsp;. This prevents many scaling problems.
</p name="switchToTextMode:blank literal line">


<p name="switchToTextMode:write non-code line">
Good examples of 
<i>thread placement</i>
 on the
<i>Intel Knight's Landing</i>
:
</p name="switchToTextMode:write blank line">


<p name="switchToTextMode:write non-code line">
<a href=https://software.intel.com/en-us/articles/process-and-thread-affinity-for-intel-xeon-phi-processors-x200>https://software.intel.com/en-us/articles/process-and-thread-affinity-for-intel-xeon-phi-processors-x200</a>
</p name="switchToTextMode:write blank line">



<p name="switchToTextMode:write non-code line">
As an example, consider a code where two threads write to a shared
location.
<div class="card">
  <div class="card-header" id="headingOne">
    <h5 class="mb-0">
      <button class="btn btn-link" data-toggle="collapse" data-target="#shareboth" aria-expanded="false" aria-controls="shareboth">
        C Code: shareboth
      </button>
    </h5>
  </div>
  <div id="shareboth" class="collapse">
  <pre>
// sharing.c
#pragma omp parallel
  { // not a parallel for: just a bunch of reps
    for (int j = 0; j &lt; reps; j++) {
#pragma omp for schedule(static,1)
      for (int i = 0; i &lt; N; i++){
#pragma omp atomic
	a++;  
      }
</p name="switchToTextMode:write blank line">

      
<p name="switchToTextMode:write non-code line">
    }
  }
</pre>
</div>
</div>
There is now a big difference in runtime depending on how close the
threads are. We test this on a processor with both cores and
hyperthreads. First we bind the OpenMP threads to the cores:
<!-- environment: verbatim start embedded generator -->
<pre>
OMP_NUM_THREADS=2 OMP_PLACES=cores OMP_PROC_BIND=close ./sharing
run time = 4752.231836usec
sum = 80000000.0
</pre>
<!-- environment: verbatim end embedded generator -->
Next we force the OpenMP threads to bind to hyperthreads inside one core:
<!-- environment: verbatim start embedded generator -->
<pre>
OMP_PLACES=threads OMP_PROC_BIND=close ./sharing
run time = 941.970110usec
sum = 80000000.0
</pre>
<!-- environment: verbatim end embedded generator -->
Of course in this example the inner loop is pretty much meaningless
and parallelism does not speed up anything:
<!-- environment: verbatim start embedded generator -->
<pre>
OMP_NUM_THREADS=1 OMP_PLACES=cores OMP_PROC_BIND=close ./sharing
run time = 806.669950usec
sum = 80000000.0
</pre>
<!-- environment: verbatim end embedded generator -->
However, we see that the two-thread result is almost as fast, meaning
that there is very little parallelization overhead.
</p name="switchToTextMode:blank literal line">




<h2><a id="First-touch">25.2</a> First-touch</h2>
<p name="switchToTextMode:write non-code line">
crumb trail:  > <a href="omp-affinity.html">omp-affinity</a> > <a href="omp-affinity.html#First-touch">First-touch</a>
</p name="switchToTextMode:blank literal line">


<p name="switchToTextMode:write non-code line">
The affinity issue shows up in the 
<!-- index:first-touch --><i>first-touch</i>
phenomemon.
</p name="switchToTextMode:blank literal line">


<p name="switchToTextMode:write non-code line">
A little background knowledge. Memory is organized in
<i>memory page</i>
s,
and what we think of as `addresses' really
<i>virtual address</i>
es,
mapped to 
<i>physical address</i>
es,
through a 
<i>page table</i>
&nbsp;.
</p name="switchToTextMode:blank literal line">


<p name="switchToTextMode:write non-code line">
This means that data in your program can be anywhere in physical memory.
In particular, on a 
<i>dual socket</i>
 node,
the memory can be mapped to either of the sockets.
</p name="switchToTextMode:blank literal line">


<p name="switchToTextMode:write non-code line">
The next thing to know is that
memory allocated with 
<!-- index:malloc --><tt>malloc</tt>
 and like
routines is not immediately mapped; that only happens when data is
written to it. In light of this, consider the following OpenMP code:
<!-- environment: lstlisting start embedded generator -->
<pre>
double *x = (double*) malloc(N*sizeof(double));

for (i=0; i&lt;N; i++)
  x[i] = 0;

#pragma omp parallel for
for (i=0; i&lt;N; i++)
  .... something with x[i] ...
</pre>
<!-- environment: lstlisting end embedded generator -->
Since the initialization loop is not parallel it is executed by the
master thread, making all the memory associated with the socket of
that thread. Subsequent access by the other socket will then access
data from memory not attached to that socket.
</p name="switchToTextMode:blank literal line">


<p name="switchToTextMode:write non-code line">
Let's consider an example. We make the initialization
parallel subject to an option:
<div class="card">
  <div class="card-header" id="headingOne">
    <h5 class="mb-0">
      <button class="btn btn-link" data-toggle="collapse" data-target="#heatinitfirst" aria-expanded="false" aria-controls="heatinitfirst">
        C Code: heatinitfirst
      </button>
    </h5>
  </div>
  <div id="heatinitfirst" class="collapse">
  <pre>
// heat.c
#pragma omp parallel if (init&gt;0)
  {
#pragma omp for
    for (int i=0; i&lt;N; i++)
      y[i] = x[i] = 0.;
    x[0] = 0; x[N-1] = 1.;
  }
</pre>
</div>
</div>
</p name="switchToTextMode:blank literal line">


<p name="switchToTextMode:write non-code line">
If the initialization is not parallel, the array will be mapped
to the socket of the master thread; if it is parallel,
it may be mapped to different sockets, depending on where the threads run.
</p name="switchToTextMode:blank literal line">


<p name="switchToTextMode:write non-code line">
As a simple application
we run a heat equation, which is parallel,
though not embarassingly so:
<div class="card">
  <div class="card-header" id="headingOne">
    <h5 class="mb-0">
      <button class="btn btn-link" data-toggle="collapse" data-target="#heatmethodrun" aria-expanded="false" aria-controls="heatmethodrun">
        C Code: heatmethodrun
      </button>
    </h5>
  </div>
  <div id="heatmethodrun" class="collapse">
  <pre>
for (int it=0; it&lt;1000; it++) {
#pragma omp parallel for
  for (int i=1; i&lt;N-1; i++)
    y[i] = ( x[i-1]+x[i]+x[i+1] )/3.;
#pragma omp parallel for
  for (int i=1; i&lt;N-1; i++)
    x[i] = y[i];
}
</pre>
</div>
</div>
</p name="switchToTextMode:blank literal line">


<p name="switchToTextMode:write non-code line">
On the 
<i>TACC Frontera</i>
 machine, with dual 28-core
<i>Intel Cascade Lake</i>
 processors,
we use the following settings:
</p name="switchToTextMode:blank literal line">


<p name="switchToTextMode:starting EnvironmentLineGenerator">
<!-- environment: verbatim start embedded generator -->
<pre>
export OMP_PLACES=cores
export OMP_PROC_BIND=close
# no parallel initialization
make heat && OMP_NUM_THREADS=56 ./heat
# yes parallel initialization
make heat && OMP_NUM_THREADS=56 ./heat 1
</pre>
<!-- environment: verbatim end embedded generator -->
</p name="switchToTextMode:blank literal line">


<p name="switchToTextMode:write non-code line">
This gives us a remarkable difference in runtime:
<!-- environment: itemize start embedded generator -->
<ul>
<!-- TranslatingLineGenerator itemize -->
<li>
  Sequential init: avg=2.089, stddev=0.1083
<li>
  Parallel init: avg=1.006, stddev=0.0216
<!-- translatinglinegenerator end: itemize -->
</ul>
<!-- environment: itemize end embedded generator -->
This large difference will be mitigated
for algorithms with higher arithmetic intensity.
</p name="switchToTextMode:blank literal line">


<p name="switchToTextMode:starting TextBlockLineGenerator">
<!-- environment: exercise start embedded generator -->
<b>Exercise</b>
<!-- TranslatingLineGenerator exercise -->
  How do the OpenMP dynamic schedules relate to this issue?
<!-- translatinglinegenerator end: exercise -->
<br><i>End of exercise</i>
<!-- environment: exercise end embedded generator -->
</p name="switchToTextMode:blank literal line">


<h3><a id="C++">25.2.1</a> C++</h3>
<p name="switchToTextMode:write non-code line">
crumb trail:  > <a href="omp-affinity.html">omp-affinity</a> > <a href="omp-affinity.html#First-touch">First-touch</a> > <a href="omp-affinity.html#C++">C++</a>
</p name="switchToTextMode:blank literal line">



<p name="switchToTextMode:write non-code line">
The problem with realizing first-touch in 
<i>C++</i>
%
</p name="switchToTextMode:blank literal line">


<p name="switchToTextMode:write non-code line">
is that  <tt>std::vector</tt>  fills its allocation with default values.
This is known as `value-initialization', and it makes
<!-- environment: lstlisting start embedded generator -->
<pre>
vector&lt;double> x(N);
</pre>
<!-- environment: lstlisting end embedded generator -->
equivalent to the non-parallel allocation and initialization above.
</p name="switchToTextMode:blank literal line">


<p name="switchToTextMode:write non-code line">
Here is a solution.
<!-- environment: cppnote start embedded generator -->
<b>C++ note</b>
<!-- TranslatingLineGenerator cppnote -->
  Default initialization is a problem.
  We make a template for uninitialized types:
<div class="card">
  <div class="card-header" id="headingOne">
    <h5 class="mb-0">
      <button class="btn btn-link" data-toggle="collapse" data-target="#cppuninitial" aria-expanded="false" aria-controls="cppuninitial">
        C++ Code: cppuninitial
      </button>
    </h5>
  </div>
  <div id="cppuninitial" class="collapse">
  <pre>
// heatalloc.cxx
template&lt;typename T&gt;
struct uninitialized {
  uninitialized() {};
  T val;
  constexpr operator T() const {return val;};
  T operator=( const T&& v ) { val = v; return val; };
};
</pre>
</div>
</div>
</p name="switchToTextMode:blank literal line">


<p name="switchToTextMode:write non-code line">
  so that we can create vectors that behave normally:
<div class="card">
  <div class="card-header" id="headingOne">
    <h5 class="mb-0">
      <button class="btn btn-link" data-toggle="collapse" data-target="#cppuninitialvec" aria-expanded="false" aria-controls="cppuninitialvec">
        C++ Code: cppuninitialvec
      </button>
    </h5>
  </div>
  <div id="cppuninitialvec" class="collapse">
  <pre>
vector&lt;uninitialized&lt;double&gt;&gt; x(N),y(N);
</p name="switchToTextMode:write blank line">


<p name="switchToTextMode:write non-code line">
#pragma omp parallel for
for (int i=0; i&lt;N; i++)
  y[i] = x[i] = 0.;
x[0] = 0; x[N-1] = 1.;
</pre>
</div>
</div>
<!-- translatinglinegenerator end: cppnote -->
<i>End of C++ note</i>
<!-- environment: cppnote end embedded generator -->
</p name="switchToTextMode:blank literal line">


<p name="switchToTextMode:write non-code line">
Running the code with the regular definition of a vector,
and the above modification,
reproduces the runtimes of the C&nbsp;variant above.
</p name="switchToTextMode:blank literal line">


<p name="switchToTextMode:write non-code line">
Another option is to wrap memory allocated with 
<tt>new</tt>
in a  <tt>unique_ptr</tt> :
<div class="card">
  <div class="card-header" id="headingOne">
    <h5 class="mb-0">
      <button class="btn btn-link" data-toggle="collapse" data-target="#newuninitial" aria-expanded="false" aria-controls="newuninitial">
        C++ Code: newuninitial
      </button>
    </h5>
  </div>
  <div id="newuninitial" class="collapse">
  <pre>
// heatptr.cxx
unique_ptr&lt;double[]&gt; x( new double[N] );
unique_ptr&lt;double[]&gt; y( new double[N] );
</p name="switchToTextMode:write blank line">


<p name="switchToTextMode:write non-code line">
#pragma omp parallel for
for (int i=0; i&lt;N; i++) {
  y[i] = x[i] = 0.;
}
x[0] = 0; x[N-1] = 1.;
</pre>
</div>
</div>
</p name="switchToTextMode:blank literal line">


<p name="switchToTextMode:write non-code line">
Note that this gives fairly elegant code,
since square bracket indexing is overloaded for  <tt>unique_ptr</tt> .
The only disadvantage is that we can not query the 
<tt>size</tt>
of these arrays. Or do bound checking with 
<tt>at</tt>
&nbsp;,
but in high performance contexts that is usually not appropriate anyway.
</p name="switchToTextMode:blank literal line">



<p name="switchToTextMode:starting EnvironmentLineGenerator">
<!-- environment: comment start embedded generator -->
</p name="switchToTextMode:write blank line">


<!-- TranslatingLineGenerator comment -->
<!-- translatinglinegenerator end: comment -->

<p name="switchToTextMode:write non-code line">
<!-- environment: comment end embedded generator -->
</p name="switchToTextMode:blank literal line">


<h3><a id="Remarks">25.2.2</a> Remarks</h3>
<p name="switchToTextMode:write non-code line">
crumb trail:  > <a href="omp-affinity.html">omp-affinity</a> > <a href="omp-affinity.html#First-touch">First-touch</a> > <a href="omp-affinity.html#Remarks">Remarks</a>
</p name="switchToTextMode:blank literal line">


<p name="switchToTextMode:write non-code line">
You could move pages with 
<!-- index:move_pages --><tt>move_pages</tt>
&nbsp;.
</p name="switchToTextMode:blank literal line">


<p name="switchToTextMode:write non-code line">
By regarding affinity,
in effect you are adopting an 
<span title="acronym" ><i>SPMD</i></span>
 style of programming.
You could make this explicit by having each thread allocate its part
of the arrays separately, and storing a private pointer as
<tt>threadprivate</tt>
&nbsp;
<a href="https://theartofhpc.com//pcse/bibliography.html#Liu:2003:OMP-SPMD">[Liu:2003:OMP-SPMD]</a>
&nbsp;. However, this
makes it impossible for threads to access each other's parts of the
distributed array, so this is only suitable for
total 
<i>data parallel</i>
 or
<i>embarrassingly parallel</i>
 applications.
</p name="switchToTextMode:blank literal line">


<p name="switchToTextMode:starting EnvironmentLineGenerator">
<!-- environment: comment start embedded generator -->
</p name="switchToTextMode:write blank line">


<!-- TranslatingLineGenerator comment -->
<!-- translatinglinegenerator end: comment -->

<p name="switchToTextMode:write non-code line">
<!-- environment: comment end embedded generator -->
</p name="switchToTextMode:blank literal line">


<h2><a id="AffinitycontroloutsideOpenMP">25.3</a> Affinity control outside OpenMP</h2>
<p name="switchToTextMode:write non-code line">
crumb trail:  > <a href="omp-affinity.html">omp-affinity</a> > <a href="omp-affinity.html#AffinitycontroloutsideOpenMP">Affinity control outside OpenMP</a>
</p name="switchToTextMode:blank literal line">


<p name="switchToTextMode:write non-code line">
There are various utilities to control process and thread placement.
</p name="switchToTextMode:blank literal line">


<p name="switchToTextMode:write non-code line">
Process placement can be controlled on the Operating system level by
\indextermttdef{numactl}
</p name="switchToTextMode:starting EnvironmentLineGenerator">

<p name="switchToTextMode:starting TextBlockLineGenerator">
<!-- environment: tacc start embedded generator -->
</p name="switchToTextMode:write blank line">


<!-- TranslatingLineGenerator tacc -->
<!-- translatinglinegenerator end: tacc -->

<p name="switchToTextMode:write non-code line">
<!-- environment: tacc end embedded generator -->
</p name="switchToTextMode:ending EnvironmentLineGenerator">

<p name="switchToTextMode:write non-code line">
on Linux (also 
<!-- index:taskset --><tt>taskset</tt>
&nbsp;); Windows
<!-- index:start/affinity --><tt>start/affinity</tt>
&nbsp;.
</p name="switchToTextMode:blank literal line">


<p name="switchToTextMode:write non-code line">
Corresponding system calls: 
<!-- index:pbing --><tt>pbing</tt>
 on Solaris,
<!-- index:sched_setaffinity --><tt>sched_setaffinity</tt>
 on Linux,
<!-- index:SetThreadAffinityMask --><tt>SetThreadAffinityMask</tt>
 on Windows.
</p name="switchToTextMode:blank literal line">


<p name="switchToTextMode:write non-code line">
Corresponding environment variables: 
<!-- index:SUNW_MP_PROCBIND --><tt>SUNW_MP_PROCBIND</tt>
 on
Solaris, 
<!-- index:KMP_AFFINITY --><tt>KMP_AFFINITY</tt>
 on Intel.
</p name="switchToTextMode:blank literal line">


<p name="switchToTextMode:write non-code line">
The 
<i>Intel compiler</i>
 has an
environment variable for affinity control:
<!-- environment: verbatim start embedded generator -->
<pre>
export KMP_AFFINITY=verbose,scatter
</pre>
<!-- environment: verbatim end embedded generator -->
values: 
<tt>none,scatter,compact</tt>
</p name="switchToTextMode:blank literal line">


<p name="switchToTextMode:write non-code line">
For 
<i>gcc</i>
:
<!-- environment: verbatim start embedded generator -->
<pre>
export GOMP_CPU_AFFINITY=0,8,1,9
</pre>
<!-- environment: verbatim end embedded generator -->
</p name="switchToTextMode:blank literal line">


<p name="switchToTextMode:write non-code line">
For the 
<i>Sun compiler</i>
:
<!-- environment: verbatim start embedded generator -->
<pre>
SUNW_MP_PROCBIND
</pre>
<!-- environment: verbatim end embedded generator -->
</p name="switchToTextMode:blank literal line">


<h2><a id="Tests">25.4</a> Tests</h2>
<p name="switchToTextMode:write non-code line">
crumb trail:  > <a href="omp-affinity.html">omp-affinity</a> > <a href="omp-affinity.html#Tests">Tests</a>
</p name="switchToTextMode:blank literal line">


<p name="switchToTextMode:write non-code line">
We take a simple loop and consider the influence of binding parameters.
</p name="switchToTextMode:blank literal line">


<p name="switchToTextMode:write non-code line">
<div class="card">
  <div class="card-header" id="headingOne">
    <h5 class="mb-0">
      <button class="btn btn-link" data-toggle="collapse" data-target="#ompsineloop" aria-expanded="false" aria-controls="ompsineloop">
        C Code: ompsineloop
      </button>
    </h5>
  </div>
  <div id="ompsineloop" class="collapse">
  <pre>
// speedup.c
#pragma omp parallel for
      for (int ip=0; ip&lt;N; ip++) {
        for (int jp=0; jp&lt;M; jp++) {
          double f = sin( values[ip] );
          values[ip] = f;
        }
      }   
</pre>
</div>
</div>
</p name="switchToTextMode:blank literal line">


<h3><a id="Lonestar6">25.4.1</a> Lonestar 6</h3>
<p name="switchToTextMode:write non-code line">
crumb trail:  > <a href="omp-affinity.html">omp-affinity</a> > <a href="omp-affinity.html#Tests">Tests</a> > <a href="omp-affinity.html#Lonestar6">Lonestar 6</a>
</p name="switchToTextMode:blank literal line">


<p name="switchToTextMode:write non-code line">
Lonestar 6, dual socket 
<i>AMD Milan</i>
&nbsp;, total 112 cores:
figure&nbsp;
<a href="omp-affinity.html#25.1">25.1</a>
&nbsp;.
</p name="switchToTextMode:blank literal line">


<p name="switchToTextMode:starting EnvironmentLineGenerator">
</p name="switchToTextMode:starting FigureLineGenerator">

<p name="switchToTextMode:starting TranslatingLineGenerator">
<!-- environment: figure start embedded generator -->
<!-- TranslatingLineGenerator figure -->
<img src="plots/speedup-ls6.jpg" width=800></img>
<!-- environment: tikzpicture start embedded generator -->
</p name="switchToTextMode:write blank line">


<!-- TranslatingLineGenerator tikzpicture -->
<!-- translatinglinegenerator end: tikzpicture -->

<p name="switchToTextMode:write non-code line">
<!-- environment: tikzpicture end embedded generator -->
<p name="caption">TIKZPICTURE 25.1: Speedup as function of thread count, Lonestar 6 cluster, different binding parameters</p>
<!-- translatinglinegenerator end: figure -->
<!-- environment: figure end embedded generator -->
</p name="switchToTextMode:blank literal line">


<h3><a id="Frontera">25.4.2</a> Frontera</h3>
<p name="switchToTextMode:write non-code line">
crumb trail:  > <a href="omp-affinity.html">omp-affinity</a> > <a href="omp-affinity.html#Tests">Tests</a> > <a href="omp-affinity.html#Frontera">Frontera</a>
</p name="switchToTextMode:blank literal line">


<p name="switchToTextMode:write non-code line">
<i>Intel Cascade Lake</i>
&nbsp;, dual socket, 56 cores total;
figure&nbsp;
<a href="omp-affinity.html#25.2">25.2</a>
&nbsp;.
</p name="switchToTextMode:blank literal line">


<p name="switchToTextMode:write non-code line">
For all core counts to half the total,
performance for all binding strategies seems equal.
After that , 
<tt>close</tt>
 and 
<tt>spread</tt>
 perform equally,
but the speedup for the 
<tt>false</tt>
 value gives erratic numbers.
</p name="switchToTextMode:blank literal line">


<p name="switchToTextMode:starting EnvironmentLineGenerator">
</p name="switchToTextMode:starting FigureLineGenerator">

<p name="switchToTextMode:starting TranslatingLineGenerator">
<!-- environment: figure start embedded generator -->
<!-- TranslatingLineGenerator figure -->
<img src="plots/speedup-frontera.jpg" width=800></img>
<!-- environment: tikzpicture start embedded generator -->
</p name="switchToTextMode:write blank line">


<!-- TranslatingLineGenerator tikzpicture -->
<!-- translatinglinegenerator end: tikzpicture -->

<p name="switchToTextMode:write non-code line">
<!-- environment: tikzpicture end embedded generator -->
<p name="caption">TIKZPICTURE 25.2: Speedup as function of thread count, Frontera cluster, different binding parameters</p>
<!-- translatinglinegenerator end: figure -->
<!-- environment: figure end embedded generator -->
</p name="switchToTextMode:blank literal line">


<h3><a id="Stampede2skylake">25.4.3</a> Stampede2 skylake</h3>
<p name="switchToTextMode:write non-code line">
crumb trail:  > <a href="omp-affinity.html">omp-affinity</a> > <a href="omp-affinity.html#Tests">Tests</a> > <a href="omp-affinity.html#Stampede2skylake">Stampede2 skylake</a>
</p name="switchToTextMode:blank literal line">


<p name="switchToTextMode:write non-code line">
Dual 24-core 
<i>Intel Skylake</i>
;
figure&nbsp;
<a href="omp-affinity.html#25.3">25.3</a>
&nbsp;.
</p name="switchToTextMode:blank literal line">


<p name="switchToTextMode:write non-code line">
We see that 
<tt>close</tt>
 binding gives worse performance than 
<tt>spread</tt>
&nbsp;.
Setting binding to 
<tt>false</tt>
 only gives bad performance for large core counts.
</p name="switchToTextMode:blank literal line">


<p name="switchToTextMode:starting EnvironmentLineGenerator">
</p name="switchToTextMode:starting FigureLineGenerator">

<p name="switchToTextMode:starting TranslatingLineGenerator">
<!-- environment: figure start embedded generator -->
<!-- TranslatingLineGenerator figure -->
<img src="plots/speedup-s2.jpg" width=800></img>
<!-- environment: tikzpicture start embedded generator -->
</p name="switchToTextMode:write blank line">


<!-- TranslatingLineGenerator tikzpicture -->
<!-- translatinglinegenerator end: tikzpicture -->

<p name="switchToTextMode:write non-code line">
<!-- environment: tikzpicture end embedded generator -->
<p name="caption">TIKZPICTURE 25.3: Speedup as function of thread count, Stampede2 skylake cluster, different binding parameters</p>
<!-- translatinglinegenerator end: figure -->
<!-- environment: figure end embedded generator -->
</p name="switchToTextMode:blank literal line">


<h3><a id="Stampede2KnightsLanding">25.4.4</a> Stampede2 Knights Landing</h3>
<p name="switchToTextMode:write non-code line">
crumb trail:  > <a href="omp-affinity.html">omp-affinity</a> > <a href="omp-affinity.html#Tests">Tests</a> > <a href="omp-affinity.html#Stampede2KnightsLanding">Stampede2 Knights Landing</a>
</p name="switchToTextMode:blank literal line">


<p name="switchToTextMode:write non-code line">
We test on a single socket 68-core processor:
the 
<i>Intel Knights Landing</i>
&nbsp;.
</p name="switchToTextMode:blank literal line">


<p name="switchToTextMode:write non-code line">
Since this is a single socket design,
we don't distinguish between the 
<tt>close</tt>
 and 
<tt>spread</tt>
 binding.
However, the binding value of 
<tt>true</tt>
 shows good speedup
--&nbsp;in fact beyond the core count&nbsp;--
while 
<tt>false</tt>
 gives worse performance than in other architectures.
</p name="switchToTextMode:blank literal line">


<p name="switchToTextMode:starting EnvironmentLineGenerator">
</p name="switchToTextMode:starting FigureLineGenerator">

<p name="switchToTextMode:starting TranslatingLineGenerator">
<!-- environment: figure start embedded generator -->
<!-- TranslatingLineGenerator figure -->
<img src="plots/speedup-knl.jpg" width=800></img>
<!-- environment: tikzpicture start embedded generator -->
</p name="switchToTextMode:write blank line">


<!-- TranslatingLineGenerator tikzpicture -->
<!-- translatinglinegenerator end: tikzpicture -->

<p name="switchToTextMode:write non-code line">
<!-- environment: tikzpicture end embedded generator -->
<p name="caption">TIKZPICTURE 25.4: Speedup as function of thread count, Stampede2 Knights Landing cluster, different binding parameters</p>
<!-- translatinglinegenerator end: figure -->
<!-- environment: figure end embedded generator -->
</p name="switchToTextMode:blank literal line">


<h3><a id="Longhorn">25.4.5</a> Longhorn</h3>
<p name="switchToTextMode:write non-code line">
crumb trail:  > <a href="omp-affinity.html">omp-affinity</a> > <a href="omp-affinity.html#Tests">Tests</a> > <a href="omp-affinity.html#Longhorn">Longhorn</a>
</p name="switchToTextMode:blank literal line">


<p name="switchToTextMode:write non-code line">
Dual 20-core 
<i>IBM Power9</i>
&nbsp;, 4&nbsp;hyperthreads;
<a href="omp-affinity.html#25.5">25.5</a>
</p name="switchToTextMode:blank literal line">


<p name="switchToTextMode:write non-code line">
Unlike the Intel processors, here we use the hyperthreads.
Figure&nbsp;
<a href="omp-affinity.html#25.5">25.5</a>
 shows dip in the speedup
at 40 threads.
For higher thread counts the speedup increases to well beyond the
physical core count of&nbsp;$40$.
</p name="switchToTextMode:blank literal line">


<p name="switchToTextMode:starting EnvironmentLineGenerator">
</p name="switchToTextMode:starting FigureLineGenerator">

<p name="switchToTextMode:starting TranslatingLineGenerator">
<!-- environment: figure start embedded generator -->
<!-- TranslatingLineGenerator figure -->
<img src="plots/speedup-longhorn.jpg" width=800></img>
<!-- environment: tikzpicture start embedded generator -->
</p name="switchToTextMode:write blank line">


<!-- TranslatingLineGenerator tikzpicture -->
<!-- translatinglinegenerator end: tikzpicture -->

<p name="switchToTextMode:write non-code line">
<!-- environment: tikzpicture end embedded generator -->
<p name="caption">TIKZPICTURE 25.5: Speedup as function of thread count, Longhorn cluster, different binding parameters</p>
<!-- translatinglinegenerator end: figure -->
<!-- environment: figure end embedded generator -->
</p name="switchToTextMode:blank literal line">


</div>
<a href="index.html">Back to Table of Contents</a>
